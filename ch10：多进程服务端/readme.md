# 多进程服务端
三种服务端：
- 多进程、
- 多路复用、
- 多线程（线程数量与客户端数量相当）

多进程在Windows下不适用
## 关于线程
创建线程：fork() 
> 两个进程都执行fork函数后的语句；
>
> 子进程的fork返回值为0，父进程获得子进程的id

僵尸进程的销毁方式：向父进程传递子进程的`exit`参数值/`return`的返回值。父进程需要主动请求获取该值，否则操作系统一直保存该值（父进程收回自己的孩子）
> 僵尸进程的状态为`Z+`

### wait
通过int*保存exit参数或者return的返回值：
- 对应于：WIFEXITED/WEXITSTATUS，通过这两个宏查看是否正常终止和返回值是多少
> 调用wait时如果没有已经终止的子进程，程序将阻塞直到有子进程终止位置！所以慎用wait

### waitpid
- 第一个参数为期待终止子进程的pid；如果传入-1，则可等待任意子进程终止；
- 第二个参数同wait的参数；
- 第三个参数：传入`sys/wait.h`的`WNOHANG`，即使没有子进程终止程序也不会被阻塞，而是**返回0并退出函数**


## 信号处理机制
### 通过`signal`注册：
- 第一个参数是发生特殊情况的事件：P167（子进程终止的事件`SIGCHLD`）
- 第二参数：处理动作的函数，返回值void，参数int

这里使用alarm函数（P168）进行演示

P169：调用注册函数的是操作系统。如果处于sleep状态的进程被唤醒，就不会再进入sleep

### sigaction注册
signal函数很少用，只是为了保证兼容性。更多的是用sigaction：

需要认识一个同名结构体`sigaction`：
- 还是void返回类型、int参数类型的指针，用于处理
- 指定信号的相关选项和特性，与目前的僵尸进程无关，剩下两个参数初始化为0即可（`sa_mask`通过调用`sugemptyset()`函数来初始化）

sigaction：
- 信号信息，同signal的第一参数
- sigaction地址值
- 获取之前注册的信号处理函数指针，不需要则传递0

## 多进程服务端
1. 通过fork，子进程获得父进程获得的客户端套接字fd
2. 明确子进程是写回数据的，所以要关闭不必要的子进程中的服务端套接字fd
> fork后不会赋值套接字，套接字是操作系统维护的，只是复制了fd

## 多进程服务端：分割TCP的I/O
目的：分割后的客户端可以连续发送数据，提高数据的传输量。P180上
> 一个进程同时写和读，只能等读完了再写下一个


